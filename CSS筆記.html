<!DOCTYPE html>
<html>
	<head>
		<title>網頁名稱</title>
		<meta charset="utf-8"/>		/*通用編碼*/
		<meta name="keyword" content="網頁,關鍵字,編碼"/>
		<meta name="description" content="此網頁用於示範head裡meta元素用法"/>
		<meta name="viewport" content="width=device-width, initial-scale=1" />
			<!-- width=device-width :瀏覽器寬度等於裝置螢幕寬度 
				 initial-scale=1 :畫面大小保持不變 -->
		
		<link rel="stylesheet" href="reset.css">  <!-- css reset用，要有檔案才會生效 -->
		參考網站:
		caniuse <!-- 函式適用的瀏覽器 -->
		fakeimg <!-- 假圖產生器，取得臨時適用的img -->
		https://picsum.photos/200/300?random=1 <!-- 假圖產生器，直接使用 -->
		Normail.css & Reset css <!-- css reset 資源-->
		https://fonts.google.com/<!-- link方式，加入額外字體 -->
		The icons	<!-- 各種符號，先Download資料庫，再link引用 -->
		https://www.flaticon.com/ <!-- 符號 -->
		
		https://developers.google.com/speed/libraries <!-- google提供的外部函式庫連結(jQuery) -->
		<style type="text/css">
			background{
				url("www")  50% 		repeat
				圖片來源   	圖片位置	重複與否
				}
			background{
				#84C1FF 	red		rgb(225,0,0)
				單一顏色
				}
				
			#色彩應用:
				
				i. 單一色彩:
					#84C1FF		red		rgb(225,0,0)
					
					hsla(360,60%,40%)
					<!-- hsla( [色相0~360], [飽和度0~100%], [亮度0~100%] ) -->
				
				ii. 透明色彩:
					rgba(0,0,0,0)	transparent
	
			text-align:	center;	文字水平置中
			line-height:200px;	文字垂直置中
			
			@import url();
			<!-- css中，外部link使用方式 -->
			
			<!-- @media queries 用法(RWD回應式設計) -->
			<!-- type and feature 為一條件 -->
			@media screen and (max-width:600px){
			.body{ height:2000px;}
			}
		</style>
		<script type="text/javascript">
		i.	function init(){
			// body靜態資料一載入完即觸發此函式
			// 可以放setTimeout等函式
			;}
			
		ii.	window.onload=function(){
			// 和 body onload="init()" 觸發效果幾乎一樣
			// 同樣可以放setTimeout等函式			
			;}
		</script>
	</head>
	<body onload="init()">
	
		<html 應用>
		空白字元: &nbsp
		copyright c字元: &copy
		
		<select>
			<option value = "1">aaa</option>
		</select>
			使用 value 送出表單時，會送出 value 值，若沒有用 value 則會送出 option 內容

		<a href="URL" >連結文字</a>
			target:
			
			i. _self
			<!-- 原分頁窗開啟 -->
			
			ii._blank
			<!-- 新分頁窗開啟 -->
			
		<img src="URL" alt="未顯示圖片時，顯示字串">
		
		<input type="text">
		type="text"			<!-- 選擇input類型 -->
		placeholder="XXXX"	<!-- 灰色預設字(不實際存在) -->
		value="xxx"			<!-- 已經填在input的字(實際存在) -->
		
		type="button"		<!-- 獨特input類型:button -->
		value="xxx"			<!-- button裡的字串 -->
		
		<label for="id"></label>
			<!-- 可以連結至想連結的input，隔空也可 -->
		
		<button></button>
			<!-- 按鈕 -->
			
		<table>		<!-- table基本架構 -->
			<caption></caption>
			<thead></thead>
			<tbody></tbody>
			<tfoot></tfoot>
		</table>
		
		<tr>		<!-- tr:列, td:行 -->
			<th></th>	<!-- th等於td，字型使用粗體代表標頭 -->
			<td></td>
			<td></td>
		</tr>
		
		<td colspan="2"></td> <!-- 跨行(左右) -->
		<td rowspan="2"></td> <!-- 跨列(上下) -->
			<!-- 跨越thead、tbody、tfoot則不會生效 -->
		
		<CSS 樣式應用>	
		border家族 (同樣可適用於table)
		i. border-style: 線條樣式
			border-style: solid實線 dashed虛線;
			
		ii. border-color: 線條顏色
			border-color: red #FF0000;
			
		iii. border-width: 線條寬度
			border-width:5px;
			
		iv. border: 綜合使用
			border: [線條樣式] [線條顏色] [線條寬度];
		<!-- 可任意互換位置，也可任意省略 -->
			
		v. 指定特定邊 加入 top,bottom,left,right;
			a. 使用 top,bottom,left,right
			   border-top-color: red;
			   border-top: solid red 5px;
			   
			b. 使用默認位置
			   border-color: [上] [右] [下] [左];
			   				 [上] [左右] [下];
							 [上下] [左右];
		<!-- border:無法使用[上右下左],無法判別-->
		
		border的table家族 <!-- (一般div無法套用，table才可以使用) -->
		i. border-collapse: 雙邊框合併成單邊框
			border-collapse:collapse;
			
		ii. border-spacing: 在雙邊框使用下，邊框的距離
			border-spacing:5px;
		
		
		background家族
		i. background-color:純色背景
			background-color: red #FF0000;
		
		ii. background-image:引用背景
			backgroung-image: url(URL);
		
		iii. background-repeat:背景重複性
			background-repeat: repeat repeat-x repeat-y no-repeat;
		
		iv. background-position:背景位置
			background-position: 50%(置中); 50% 50%(左右 上下);
		
		v. background: 綜合使用
			background: [img來源(URL 或純色)] [重複性] [背景位置]
		<!-- 可任意互換位置，也可任意省略，
			 [重複性]預設:repeat，[背景位置]預設:左上 -->
			 
		vi. background-color:rgb([r],[g],[b],[opacity]);
		<!-- 可增設第四個額外的透明度，可以省去opaciyt屬性的繼承問題 -->
		
		vii. background:linear-gradient([角度deg],[色彩1],[色彩2]);
		<!-- 漸層色，漸層色函式 linear-gradient() 算是建立一個漸層色圖片，而非色彩。
			 so,不能使用background-color來套用 -->
			 
		<!-- 進階:可使用%數( [角度deg],色彩1 50%,色彩2 50% )來產生明顯邊界 -->
		
		viii. background-size: cover 滿版
		<!-- 當圖片比容器小時，cover可以將圖片自動放大到和寬一樣，多出來的高會被裁切掉 -->
		
		font家族
		i. font-weight:字型粗細
			font-weight:bold normal ;
	
		ii. font-style:斜體字
			font-style:italic normal;
			
		iii. font-size:字型大小
			font-size:20px;
			
		iv. font-family:字體
			font-family: "新細明體";

		v. font:綜合使用
			font: [X] [X] [size] [family]
		<!-- 後方size跟family不可改順序，不可省略，weight,style則可以省略、改順序 -->
		
		vi. color:字體顏色
			color: red #FF0000;
		
		
		postion家族:
		
		i. 單一使用 position:relative:
			postion:relative;
			top:50px;
			left:100px;
		<!-- 會向下50px,向右100px,且還是會佔據原本的位置(較少用) -->
		
		ii. 單一使用 position:absolute:
			postion:absolute;
			top:50px;
			left:100px;
		<!-- 因為沒有relative屬性的父元素，預設以其父元素為基準浮著。
			 but注意，一旦加入top, left 等更改屬性:
			 若沒有relative屬性的父元素則以視窗為準向下50px,向右100px,
			 不會再佔據原本位置，像是"浮"上來的(較少用) -->
		
		iii. 移動至另一個block的相對位置:
			(父元素)block1{
			postion:relative;
			}
			(子元素)block2{
			postion:absolute;
			top:50px;
			left:100px;
			}
		<!-- 子元素會尋找有relative的父元素對齊,向下50px,向右100px,
			 且不會佔據原本的位置(最常用到),只要使用到absolue就擁有"浮"的特性-->
			 
		iv. 固定於視窗上的絕對位置:
			position:fixed;
			top:0;
			right:0;
		<!-- block會固定於視窗上的固定位置，網頁上下移動，
			 block仍然會在視窗上的固定位置 -->
			 
		# 附加屬性 z-index:1 ; 決定物件在螢幕上的顯示順序
		<!-- 必須和 position:xxx 以起使用才有效果。
			 預設為0，數字愈大離自己愈近，也可設定負值 -->
			同層元素比較，不太會有問題。but不同層比較:
				A父元素(z = 0) ~ C子元素(z = 0)
				B父元素(z = 0) ~ D子元素(z = 0)
			C元素要蓋過B元素，必須要: A父元素(z=1) 比 B父元素(z=0) z值大，
			取決於C子元素的父元素，不行直接比較。
		
		<CSS 屬性應用>
		
		9/2
		display	:inline-block	
		<!-- 依舊是block元素，but使用行內元素(inline)的排列方式，
			 應用於block水平排列，與float:left有同樣效果，且不必清除浮動，
			 如果應用的html block元素間有空格或換行，實際排版時也會空一格，
			 切版時需要十分注意 -->
		<!-- 注意:此時text-align:center有效，因為是以inline的排列方式 -->
		
				:block
		<!-- 區塊元素，像<div> -->
		
				:inline
		<!-- 區塊元素，像<span> -->		
		
				:none
		<!-- 用於隱藏block，而且隱藏後不占位-->
		
		vertical-align:top ,middle, bottom
		<!-- 應用的inline-block或 inline元素都會向上對齊，經常與display:inline-block一起使用，
			 使用於同一個元素。
			 注意: 其父元素需要設定 height-line ，其inline-block才會隨height-line高上下移動-->
		
		text-align:center
		<!-- 文字水平置中，對文字inline、inline-block 元素有效，對block元素無效 -->
		line-height:20px;
		<!-- 設定行高，文字垂直置中 -->
		text-decoration:underline, line-through;
		<!-- 文字新增底線, 刪除線-->
		
		9/3
		虛擬選擇器
		:hover
		<!-- 當滑鼠移到上面時 -->
		:fouse
		<!-- 當焦點在這邊時，只作用於表單輸入元素(input框框裡面打字時) -->
		
		9/4
		flex用法 (適合橫向 & 直向排版)
		設A為父元素，item為子元素
		
		#A{
			display:flex;	 使用flex宣告，作為外包的元素
			
			// flex-direction: row;		決定主軸方向
			<!-- row row-reverse column column-reverse 四種主軸方向-->
			<!-- 主軸 row 系列，次軸預設上到下，主軸 column 系列，次軸預設左到右 ->
			
			// flex-wrap: wrap; 	是否換行
			<!-- nowrap不換行(預設) wrap換行 -->
			flex-flow: [direction] [wrap];	<!-- direction和wrap的綜合屬性 -->
			
			justify-content: center; 主軸對齊
			<!-- flex-start:主軸順向對齊(預設) 
				 flex-end:  主軸逆向對齊 
				 center: 	中間對齊 
				 space-between:項目之間平均間隔
				 space-around: 項目之間+兩側平均間隔-->
			align-items: center;	切軸對齊
			<!-- flex-start:主軸順向對齊
				 flex-end:	主軸逆向對齊 
				 center: 	中間對齊 
				 stretch:	延伸對齊(預設) -->
			}
		
		#A>item{
			// flex-grow	:0;					<!-- 預設為零，零為無延展性 -->
			// flex-shrink	:0;					<!-- 預設為零，零為無延展性 -->
			// flex-basis	:10px;				<!-- 設定item主軸方向的寬度-->
			flex:[grow] [shrink] [basis];		<!-- 以上三個綜合屬性 -->
			
			order:-1;		<!-- 改item順序 -->
			<!-- 以0,1,2,3表示順序 -->
			align-self:	flex-start;	<!-- 個別item的切軸對齊 -->
			<!-- flex-start:主軸順向對齊
				 flex-end:	主軸逆向對齊 
				 center: 	中間對齊 
				 stretch:	延伸對齊 -->
			}
		
		9/8
		opacity: 0~1; 
		<!-- 透明度:0完全透明~1不透明 -->
		box-shadow: 10px 10px 5px black;
		<!-- block陰影: [x軸位移] [y軸位移] [擴散程度] [陰影顏色], 第二陰影... -->
		text-shadow: 10px 10px 5px black;
		<!-- block陰影: [x軸位移] [y軸位移] [擴散程度] [陰影顏色], 第二陰影... -->
		
		<!-- 進階陰影: [x軸位移 10px] [y軸位移 10px] [擴散程度 10px] [陰影半徑大小 10px](可被省略) [陰影顏色 #000], ... -->
		
		border-radius: 10px;
		<!-- 圓軸，設定半徑，50%可以使之變圓形 -->
		
		9/9
		i. transform:		<!-- 線性轉換 -->
		<!-- inline元素大部分狀況下無法使用，要使用display:inline-block 或 block -->
		
		translate(100px,100px) 
		<!-- 位移:x軸位移,y軸位移，可以使用%數-->
		scale(1.5,1.5)
		<!-- 縮放:x軸縮放,y軸縮放(都以中心點縮放) -->
		rotate(45deg)
		<!-- 旋轉:角度 -->
		shew(45deg,0)
		<!-- 歪斜:x軸歪斜,y軸歪斜 -->
		
		ii. transform: translate(100px,100px) scale(1.5,1.5) rotate(45deg) shew(45deg,0);
		<!-- 屬性一次可以放多個內容，以空格區分 -->
		
		iii. transform-origin:top left;
		<!-- 設定轉動起始點，預設:center -->
		
		CSS製作動畫: 建立動畫並套用
		
		i. 建立動畫: 
		@keyframes name1{
			0%{opacity:1}
			50%{opacity:0}
			100%{opacity:1}
		}
		<!-- 建立要建立在<style>...</style>標籤裡面，name可任意更換，
			 0%表示動畫開始，100%表示結束，{}放CSS屬性 -->
		
		ii. 套用動畫:
		.class{
			animation: name1 5s 2s infinite linear alternate;
		}
		<!-- 使用animation屬性套用動畫，
			 內容:[name] [開始到結束時間] [開始動畫前的時間延遲] [無限循環] [線性模式] [來回播放]，
			 仍有很多屬性可以查詢，可以用javascript更改class達到觸發的效果 -->	
			
		CSS+javascript製作動畫: 利用漸進式的改變屬性，產生動畫
		
		i. 設定要監控的元素(動畫的對象&方式)
		.class{
		background-color:red;
		transition : background-color 3s;
		}
		<!-- transition: [要監控的屬性1] [動畫持續時間], [要監控的屬性2] [動畫持續時間]... 
			 決定要產生動畫的元素&動執行的時間，一但background-color屬性產生任何變化，
			 都會在時間內以動畫形式漸變而成，通常以javascript觸發動畫 -->
		
		<!-- 進階用法:
			 transition: [要監控的屬性1] [動畫持續時間] [動畫開始時間延遲] [動畫速度], ....
			 [動畫開始時間延遲]:可省略，預設為 0s
			 [動畫速度]:可省略，預設為 ease ，為正常速度
			 -->	 
			 
		ii. 以javascript觸發動畫
		X.style.backgroundColor = "green";
		<!-- 以javascript改變被監控的CSS屬性，CSS屬性就會自動以動畫的方式改變 -->
		
		純粹使用javascript製作動畫: 利用更改block基本設定來產生動畫
		
		i. 取得物件要產生動畫的CSS屬性值
		var y = window.getComputedStyle(X);		<!-- y包含一大堆X元素物件的CSS屬性值 -->
		var z = y.getPropertyValue("width")		<!-- 抓出特定y的屬性值，此時z=100px -->
		
		
		ii. 利用取得的CSS屬性值直接對物件進行更改，產生動畫
		var widthvalue = parseInt(z);	<!-- "100px"轉為數值100整數 -->
		var timer = setInterval(function(){		
			if(widthvalue>200){clearInterval(timer)};
			widthvalue++;				
			X.style.width = widthvalue;}
		,100)
		
		<!-- 使用setInterval，每0.1s 增加width寬度，形成一個動畫 -->
		<!-- 可以設定if來決定動畫結束的時間點-->
		
		9/11
		overflow:	<!-- 調整卷軸的使用 -->
		
		i. visible
		<!-- 預設值，內容過多會跑出block -->
		
		ii. hidden
		<!-- 超出block的內容將會被隱藏，另一個用途是清除block的float浮動 -->
		
		iii. scroll
		<!-- x,y軸無論有無超過都會賦予卷軸 -->
		
		iv. auto
		<!-- x,y軸會視情況，有超出才會賦予卷軸 -->
		
		v. javascript 操控卷軸
			X.scrollTop	= 50;	
			<!-- 垂直軸的參數，可以直接控制垂直高度，最上方是0，值的單位是px省略不寫，可讀可寫 -->
			
			X.scrollLeft = 50;
			<!-- 水平軸的參數，可以直接控制水平幅度，最左方是0，值的單位是px省略不寫，一樣可讀可寫 -->
		9/14
		text-doceration:	<!-- 文字底線應用 -->
		i. underline: 加底線
			
		ii. none: 不加底線
			<!-- 可用於<a>連結不出現底線 -->
			
		ul標籤屬性:
		list-style-type:	<!-- li的標籤樣式 -->
		i. none 
			<!-- 去掉標籤樣式 -->
			
		9/15
		margin: 0 auto;		
			<!-- 單一block左右對齊 -->
		
		9/20
		cursor: pointer; 
			<!-- 改變滑鼠游標為手指 -->
			
		min-width & max-width: 1000px;
			<!-- 為適應視窗大小改變，設定的最小寬以及最大寬
				 與width屬性可同時存在。一般用於圖片會依照
				 視窗大小變化時，控制圖片的形變不要太大或太小。
					width:100%;
					min-width:1000px;
					max-width:1500px;
				 視窗可大可小，but範圍被限制在1000~1500px -->
		
		9/21
		偽類:
			<!-- 注意: 其影響區域只能是本身、子元素、兄弟元素、兄弟元素之子元素
				 無法影響到其 父元素 或 父元素的兄弟元素 -->
			
		i. 	:child家族:
			
			I .item:first-child, last-child
			<!-- first-child : 所有.item中的第一個.item元素 -->
			<!-- last-child : 所有.item中的最後一個.item元素 -->
			<!-- 注意: .item如果分屬於A以及B父元素之中(分兩群)，則A,B都會
				 分派出第一個 .item(一共兩個)，所以有可能選擇到多個元素，
				 此時使用A .item:first-child 可解決跨群問題-->-->

			II .item:nth-child(odd) & :nth-child(even)
			<!-- 分別為.item中的第奇數個 & 第偶數個.item元素 -->
			
			III .item:nth-child()公式版本
			<!-- 括號裡面可放有n的多項式，如:(2n+1), (3n)，而n=0,1,2,3...將會
				 依序帶入公式變(1,3,5...), (0,3,6...)，將會選取到公式帶入的項目。
				 當然也可以使用常數 nth-child(5) 也是ok的 -->
			
			<!-- 注意: .item如果分屬於A以及B父元素之中(分兩群)，則A,B都會
				 分派出公式選出來的 .item，所以有可能選擇到不同群的元素，
				 此時使用A .item:nth-child()可解決跨群問題-->
		
		ii. :of-type家族:
			
			I .item:first-of-type, last-of-type
			
			II .item:nth-of-type(odd) & :nth-of-type(even)
			
			III .item:nth-of-type()公式版本
			<!-- child家族 和 :of-type家族 用法一模一樣，差別在於:
			
				 child意指所有的子元素，so first-child 必須同時是
				 "父元素中第一個元素" 加上 "是.item項目" 兩條件符合才會生效，
				 否則第一項會直接失效。子元素都同樣比較適合使用。
				 
				 of-type則是指此元素類型，so first-of-type 將會套用在
				 "父元素中第一個此類型的元素，即那使不是第一項元素"。
				 針對混和型的一群元素來使用。
				 -->
			
		iii. :checked
			<!-- input類型為checkbox，被打勾時觸發 -->
		iv. :before & :after
			<!-- 內部必要含content:"";，可以什麼都不放， 
				 :before為元素前，:after為元素後，多用於 
				 裝飾元素。
				 注意: A:before 可視 A 為偽類的父元素 -->
				 
		v. :active
			<!-- 點擊的瞬間可產生效果 -->
		
		vi. :fouse
			<!-- input框框內可以輸入時 -->
		
		vii. :first-letter
			<!-- 元素內第一個字母 -->
			
		9/24
		偽元素::
		
		i. ::before & ::after
			<!-- 內部必要含content:"";，可以什麼都不放， 
				 ::before為元素前，::after為元素後，多用於 
				 裝飾元素 -->
				 
		9/25
		box-sizing:border-box 將padding,border列入with、height裡面
			<!-- 預設: box-sizing:content-box; (padding,border與with、height分開算)

				 通常會連下面兩行一起使用
				 box-sizing:border-box;
				 -moz-box-sizing:border-box; 	/* Firefox */
				 -webkit-box-sizing:border-box; /* Safari */
				 以確保在各個瀏覽器可以正常使用 -->
		9/30
		選擇器: *{	padding:0;	}
			<!-- 使用字元「*」，整張網頁下的所有元素都會套用設定 -->
	
		屬性選取器: a[href], input[type="text"]
			<!-- a[href] : 所有a元素中，有包含href屬性的a元素。
				 也可以包含值，input[type="text"] : 所有input元素中，
				 包含type="text"的input元素 -->
		
		兄弟系列選取器: A+B
			<!-- 適用於兄弟元素(不會跨代)，為A之後的第一個B元素 -->
			
			特殊用法:
			
			i. 有一整排.item時， .item+.item{} 可以套用到第一個項目以外的項目。
		
			ii.同一層有<h1><p><p><p>四個元素，要選到第二個<p>，可以用: h1+p+p{} 。
		
		兄弟系列選取器: A~B
			<!-- 適用於兄弟元素(不會跨代)，為A之後的所有B元素 -->
		
		10/4
		
		table邊框專用系列:
		
		i. border-collapse: 
			<!-- reset預設collapse:    所有框線不分開顯示，且互相衝突效果無法預測，
				 一般模式預設separate: 所有框線分開顯示(且不重疊) -->
		
		ii. border-spacing:
			<!-- 使用separate下，框線間的間距 -->

		10/12
		
		column-count:將文章分欄。
		
		column-gap:使用column-count分欄之後，更改產生的間隔大小。
		
		10/14
		
		outline:none;
			<!-- input未使用reset時，用於去除案到時產生的方框效果 -->
		
	</body>
	<script>
		<javascript 應用>
		元素物件節點 提取、應用
		
		var x = document.getElementById("id");			//元素物件		/*"id"可以使用變數加入判斷:("id"+y)*/
		var x = document.getElementsByName("name");		//nodelist 集合
		var x = document.getElementsByTagName("input")	//元素物件的 陣列集合
		
		X.innerHTML		//內容
		X.value			//內容
		
		X.appendChild(A);	//A -> Node 或 元素物件
		X.innerHTML = B;	//B -> 字串 或 變數 或數值
		
		
		var y = document.craeteElement("span");		//元素節點
		var y = document.createTextNode("123");		//文字節點
		
		X.parentNode	//元素物件的 往上一層父節點:Node型態
		X.childNodes	//元素物件的 子節點: 		Nodelist型態
						//連Text節點都會被包含
		--------------------------------------------------------------------------------
		
		function呼叫法*3 + this用法:
		
		1. <input onclick="func1(this)">			//靜態觸發
		function func1(x){;}
		
		2. X.onclick = func2;
		function func2(){this;}
		
		3. X.addEventListener("click",func3);		//建議:比較標準的寫法
		function func3(){this;}						//屬於動態觸發
		
		function建立方法:
		
		1. function func1(){;}
		
		2. var func1 = function(){;}	//1,2 一樣，觸發方式也一樣
		
		3. function(){;}				//匿名函式
		
		// 利用回傳值，可以把函式當作變數使用:
		// ex: var x=func1();
		// ex: if( !(func1) ){;}
		--------------------------------------------------------------------------------
		
		var x = X.getAttribute("id");		//取得元素物件 html 屬性
		X.setAttribute("id", "box_1");		//設定元素物件 html 屬性
		X.removeAttribute("id");			//移除元素物件 html 屬性
		
		X.style.borderColor = "red";		//更改CSS樣式
		X.childNodes						//DOM 模型
		
		var x = parseInt("123");			//字串 轉 整數
		var x = parseFloat("123");			//字串 轉 浮點數
		
		--------------------------------------------------------------------------------
		<'script'應用>
		
		9/6
		憑空建立可儲存資料的物件集合: 建立物件
		var Obj1 = {};					//宣告空白物件
		Obj1.x = 100;
		Obj1.y = 20;
		
		var Obj2 = new Object();		//宣告空白物件，同上效果
		Obj2.x = 100;				
		Obj2.y = 20;			
	
		function Obj3(a,b,c){		//建構式函式 (建構函式)
			this.x = a;				//( function constructor ) 	
			this.y = b;
			this.z = c;
			this.w = function(){alert(a+b+c);};		
		}
		var test1 = new Obj3(1,2,3);		
					
		9/8 
		classList.toggle :新增 或 去除 物件的class (classList 還有更多用法)
		
		X.classList.toggle("class1");
		// if class存在，刪去X物件class 的 class1值 
		// if class不存在，則新增X物件的class值 class="class1"
		// 總結:若有就刪除，若沒有就新增
		
		X.classList.add("class");
		// 為元素物件新增class="class"

		X.classList.remove("class")
		// 移除元素物件的class="class"
		
		9/8
		事件處理類別:
		i. click
		ii. change
		iii. mouseenter & mouseleave	// 子元素不觸發，比較好
		iv. mouseover & mouseout 	 	// 子元素會觸發，會觸發比較多次
		v. load		// 載入後完成，常用於body靜態資料載入完成後觸發init()。
		
		事件物件的取得:
		觸發端: X.addEventListener("click",func1);
		函式端:	function func1(ob){...ob... ;}
		
		// ob為 事件物件(Event Object)，當觸發端不輸入值時，
		// 函式端第一個值被默認為 事件物件(可以使用任何名子)
		// 事件物件:內容可包含當時滑鼠的位置 或是 當時觸發的鍵盤按鍵等等...
		
		9/8
		時間函數(自動排程):
		i. setTimeout(func1,2000)	//一次性呼叫
		
		ii. setInterval(func1,2000)	//重複呼叫
		
		回傳值(用於 取消setTimeout觸發 或 中斷setInterval迴圈):
		setTimeout & setInterval 皆有回傳值:
		var timer1 = setTimeout(func1,2000);
		var timer2 = setInterval(func1,2000);
		
		clearTimeout(timer1);	// 觸發之前取消setTimeout,可在函式內使用
		clearInterval(timer2);	// 取消setInterval迴圈
		
		9/10
		取得完整CSS樣式及應用:
		
		i. getComputedStyle: 取得物件裡的CSS樣式
			var y = window.getComputedStyle(X);
		// y將放入X元素物件所有CSS屬性值，包括沒有事先定義默認的屬性
		
		ii. getPropertyValue: 取得CSS集合中的特定值
			var z = y.getPropertyValue("width");
		// 從y裡眾多CSS屬性值中取得我們要的特定屬性，z=100px
		
		// X.style.屬性，同樣可以讀取、寫入。不同的是，
		// X.style只能讀到已經寫好的CSS樣式(而且是用javascript寫好的，CSS中已經寫入的也不算)，
		// 沒有寫好But被默認的值 無法被讀取。
		
		// EX: <div></div>無任何CSS樣式，用getComputedStyle可以取得寬高，
		// 	   但是X.style只會讀取到空白值
		
		// 用getComputedStyle取得的值(要用parseInt轉回數值)，
		// 可以用X.style寫入是沒問題的(即使CSS沒有先寫好)
		
		變數宣告觀念:
		i. var: [函式作用域] 可用範圍以function為界，以外就無法使用。
		//	var宣告全域變數: 可用於任何地方。
		//	var宣告區域變數: 可用於當前宣告的function
			
		ii. let & const: [區塊作用域] 以更小的區塊if, for作為邊界，以外無法使用。
		//	let在for, if中宣告: for, if 外的地方皆無法使用
		//	const在for, if宣告: 同樣for, if 外的地方皆無法使用，一開始必須指定值，
		//						且無法更改或是重複宣告新值(當pi等固定參數使用)
		
		this的綁定更改: bind, apply, call
		i. func2 = func1.bind({x:1})
		//	func2函式和func1一樣，只是func2的this綁定的是{x:1}物件
		
		ii. func1.apply({x:1}, [a,b])
		//	func1的this綁定成{x:1}，並直接觸發func1(a,b)，
		//  a,b為函式的輸入值
		
		iii. func1.call({x:1}, a, b)
		//  func1的this綁定成{x:1}，並直接觸發func1(a,b)，
		//  同apply效果，只是a,b不用以陣列形式帶入

		
		
	</script>
</html>
觀念:
	# Reset CSS:		
	<!-- 因為各家瀏覽器CSS默認屬性值(如:margin)不太一樣，用於統一各家CSS的預設值 -->
		i.使用*{}選取器
			*{margin:0; padding:0;}
	
		ii.使用 CSS Reset or Normalize
	
	# 使用2個以上class:
		
		<div class="box one">A</div>
		<div class="box two">B</div>
		
		.one{} -> A block
		.two{} -> B block
		.box{} -> A,B block
		.box.one{} -> A block
		.box.two{} -> B block
	
	# 關於 margin:auto; 總是可以水平置中，but"很難"垂直置中:
	
		i. 首先block被建立時，預設:水平margin會撐滿整個父元素的水平空間，
		   垂直則不會 (也順帶造成每個block換行的現象) ，就算有設定margin:50px，
		   在沒有其他特殊狀況下(如float)，margin仍然會撐滿整個水平。
		ii.so.一旦使用 margin:auto; = margin:auto auto;，水平的block可以
		   依據margin長度平分，使block水平置中。垂直預設的margin卻是0，
		   0平分還是0，所以垂直方向並不會更動。
		
		iii. 特殊狀況:margin:auto;可以達到垂直置中: fixed, absolute
			 由i, ii可知，沒辦法垂直置中的原因是因為margin沒能計算到垂直方向的長度。
			 但是使用以下條件可以:
				
				position:fixed;
				left:0;
				right:0;
				top:0;
				bottom:0;
				margin: auto;
			 使用fixed使block獨立到另一層，而使用left, right, top, bottom 
			 會計算出整個視窗大小(長寬)，有了這些數值，margin:auto即可發揮水平&垂直置中效果
				
				position:absolute;
				left:0;
				right:0;
				top:0;
				bottom:0;
				margin: auto;
			 使用absolute也有同樣效果，block會在視窗的中間，但不隨視窗移動而移動。
			 注意:是視窗中間，並不是整個網頁中間，要注意。
			  <!-- 注意:使用absolute的元素若是沒有設定with,height，
				   就算原本有子元素自動撐開，也會置中失效，
				   block將會自動撐開至與父元素大小。如果四個邊都設定5px，
				   則四邊會內縮5px，藉以控制大小-->
			  <!-- 如果要使用無設定with,height的block垂直置中，
				   可以使用以下方式(第二種垂直置中)來置中:
				   left:50%;
				   top:50%;
				   transform:translate(-50%,-50%); -->
			  
	# 三層、四層包裹系統:看筆記本
	
	# margin重疊issue:有三種狀況會產生margin重疊:
		
		i. 發生於父子元素:
			父子元素都有設定margin，父元素中，最上方元素的邊界會和父元素的邊界重疊，
			margin會重疊，so 元素上方的margin會是父元素margin或子元素margin中 最大的那個。
			底部的block也會有這種狀況。
		
		ii. 發生於相鄰2元素(如果用到flex或float狀況可能變正常):
			相鄰上下兩block元素，都有設定margin，margin會重疊，so 相鄰的距離是取最大
			元素的margin。
		
		iii. 發生於空元素(高度等於零):
			一個空元素，設定上下margin，margin隔出上下block的距離只取最大的那個。
	
	# width:100% & width:auto 差別:
		
		width預設為auto。一個子 block 在父 block裡面，其寬度預設為auto，寬度等於父 block 的寬，
		100%也有同樣效果。but 如果子元素使用absolute從父元素裡脫離出來，預設auto的子元素會因此
		縮短寬度直到剛好容得下內容(也就是寬度不再無限延伸)，but使用100%的話，
		脫離出來的子 block會維持和父元素一樣的100%寬(設定90%和其他%數同樣有此效果)。
		
		附加: width/height:100vh; 寬度/高度和"視窗高度100%"一樣，動態顯示，改變高度，寬也會隨之改變。
		
	#float應用，清除浮動:看筆記本。
		
	960system:
	
	
	
技法:
	# inline-block中間的空白字元清除:
	父元素div{
		font-size:0;
	}
	<!-- 將父元素內的字元大小設定為0 -->
	div 子元素a{
		font-size:17px;
	}
	<!-- 因css獨特性有優先權，so a元素裡的字元大小會被設定回來 -->
	
	# 置中issue:
		
		I.水平置中
		
			i.單一block元素置中:
				margin: 0 auto;
			
			ii. 單一或多個 inline元素, 文字置中:
				text-align:center;
			
			iii. 多個block元素並排置中:
				父元素{ text-align:center; }	
				子元素{ display:inline-block; }		
			
			iv. 父display:flex + 子margin:auto:產生單一block置中
				子元素加上 margin:auto ，剩下的空白會被平均分到使用到的元素兩端，
				若有兩個元素同時使用，則平均分給兩個元素的各兩端(四份)。
				注意: inline-block + margin:auto 將不會有效果。
				
		II.垂直置中:
			
			i. 單一block元素 或 多個元素 或 文字 垂直置中:(萬用置中，也能水平置中)
				父元素: display:flex;
						justify-content:center;
						align-items:center;
						
			ii. 單一block元素 垂直置中:(也能水平置中)
				父元素: display:flex;
				子元素: margin:auto;
						
			iii. 單一block元素置中: (也可水平置中)
				 父元素:position:relative;
			  	 子元素:position:absolute;
						left:0;
						right:0;
						top:0;
						bottom:0;
						margin:auto auto; /*同時水平置中*/
			
			iv. 單一block元素置中: (也可水平置中)
				父元素:position:relative;
				子元素:position:absolute;
					   left:50%;
					   top:50%;
					   transform:translate(-50%,-50%); /*同時水平置中*/
			
			v.  單行文字垂直置中:
				父元素: line-height:100px;
				
			vi. 文字垂直置中: inline-block + vertical-align: middle
				千萬不要用，世界難用，完全不知道要怎麼用!!!!
			
	# block1 元素內含 block2 & block3 ，使用flex並排。
	  使 block3 向右延伸到底:
		
		i. block3 設定css 屬性 flex-grow:1; 使其吃掉剩下的空白。
		
		ii. block3 直接設定css 屬性 width:100%; 就會自動填滿之後的空位。
	
	#有關於消失: 萬一已經設定display:flex; 要如何隱藏 block?
	
		i.使用display:none;(不會占用原本位置，完全消失)
		
		ii.使用opacity:0;(將會占用原本位置，變透明而已)
		
		iii. 使用transform:scale(0,0)(將會占用原本位置)
	
	#margin 使用負值:可以使附近block或是本身有位移的效果。類似transform效果。
	
	#html,body高度原取決於內容高度延展，若要主動改變高度:
		
		html,body{height:100%} 設html,body高度主動和網頁高度一樣。
		
		子block{ height:100vh }，也有同樣效果，只是換成內容物撐高html,body的高度。
		
	#<input type="checkbox"> + <label>可以模擬程式觸發的效果
	
	#有關裝置大小(大部分):
	手機: 360 x 640
	平板則是786 x 1024
	電腦是1366 x 768
	
	#單位意義:
	px: 一個像素
	cm: 公分
	em: 相對單位，相對於該元素本身字體大小(font-size)，1em為一倍。
		若無設定，則會找到有設定font-size的父元素作為相對依據。
	rem:相對單位，相對於根元素字體大小(font-size)。
	
	#@media條件: [media type] and ([media feature])
				 符合單一條件
				 
				 [media type] and ([media feature]) and ([media feature])
				 要同時符合兩條件

				 [media type] and ([media feature]), [media type] and ([media feature]),
				 符合任一條件
----------------------------------------------------------------------
??
段落縮排:
960system
form用法
grid
display:table,table-row,table-cell
text-indent
data-XXX
width:5em(em大小單位)
visible hidden

進階??:
表格RWD
Boostrap CDN
